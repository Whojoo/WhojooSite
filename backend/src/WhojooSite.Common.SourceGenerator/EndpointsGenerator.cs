using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace WhojooSite.Common.SourceGenerator;

[Generator]
public class EndpointsGenerator : IIncrementalGenerator
{
    private const string HintName = "EndpointsExtension.g.cs";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context
            .SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is ClassDeclarationSyntax,
                transform: (syntaxContext, _) => (ClassDeclarationSyntax)syntaxContext.Node)
            .Where(classDeclarationSyntax => classDeclarationSyntax is not null);

        var compilation = context
            .CompilationProvider
            .Combine(provider.Collect());

        context.RegisterSourceOutput(compilation, Execute);
    }

    private static void Execute(
        SourceProductionContext context,
        (Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes) tuple)
    {
        (Compilation? compilation, ImmutableArray<ClassDeclarationSyntax> classes) = tuple;

        const string prefixCode =
            """
            // <auto-generated/>
            using Microsoft.AspNetCore.Routing;

            namespace WhojooSite.Common.Web;

            public static class EndpointsExtension
            {
                public static IEndpointRouteBuilder MapGeneratedEndpoints(this IEndpointRouteBuilder endpoints)
                {
            """;

        const string suffixCode =
            """
                    return endpoints;
                }
            } 
            """;

        var stringBuilder = new StringBuilder().AppendLine(prefixCode);

        stringBuilder = AppendEndpointsToCode(stringBuilder, compilation, classes);

        stringBuilder = stringBuilder.AppendLine(suffixCode);

        context.AddSource(HintName, stringBuilder.ToString());
    }

    private static StringBuilder AppendEndpointsToCode(
        StringBuilder code,
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classes)
    {
        const string lineFormat = "\t\tnew {0}().AddEndpoint(endpoints);\n";
        foreach (var classDeclarationSyntax in classes)
        {
            if (compilation
                    .GetSemanticModel(classDeclarationSyntax.SyntaxTree)
                    .GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol symbol)
            {
                continue;
            }

            if (!IsEndpoint(symbol))
            {
                continue;
            }

            // code.AppendLine($"            new {symbol.ToDisplayString(SymbolDisplayFormat)}().AddEndpoint(endpoints);");
            code.AppendFormat(lineFormat, symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
        }

        return code;
    }

    private static bool IsEndpoint(INamedTypeSymbol symbol)
    {
        const string endpointInterfaceName = "IEndpoint";
        return symbol.AllInterfaces.Any(i => i.Name == endpointInterfaceName);
    }
}